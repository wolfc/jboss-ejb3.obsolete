<?xml version='1.0' encoding='UTF-8'?>
<chapter id="EJB3_Entities">
	<title>Introduction to Entities in EJB3</title>
	<para>
		Entity Beans of EJB2.x have been given a complete overhaul in EJB 3.0.
		Entity beans (or Entities, as they are now called) are plain Java objects that can be allocated
		with <literal>new</literal> and attached/detached/reattached to persistence storage.
		Entities are not remotable and must be accessed through the new <literal>javax.persistence.EntityManager</literal> service.
		JBoss's EJB 3.0 entity implementation is built on top of Hibernate.
	</para>

	<sect5>
		O/R Mapping :
	</sect5>
	<para>
		First let's look at the example implementation of two related Entities.
		<literal>org.jboss.tutorial.entity.bean.Order</literal> and <literal>org.jboss.tutorial.entity.bean.LineItem</literal>.
		These two entities form a one-to-many relationship.
	</para>

	<para>
		The persistence determines the persistent properties by looking for all getter/setter method pairs.
		By default, all getter/setter methods will be treated as persistence properties.
	</para>

	<para>
		Defining an Entity is easy. First, annotate the class as an <literal>@Entity</literal>. In the minimum, you must at
		least define a primary key field using the <literal>@Id</literal> annotation.

		<programlisting>
		<![CDATA[
@Id @GeneratedValue
public int getId()
{
   return id;
}
		]]>
		</programlisting>
		<note>
			<para>
				Annotations must be defined on the getter method or on the field. However, you cannot have a mix of annotations
				on the field and on the methods. The following example where we are mapping the <literal>name</literal> through
				the field and mapping the <literal>age</literal> through the method is not allowed:

				<programlisting>
					<![CDATA[
@Entity
public class Employee implements java.io.Serializable
{

	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	private long id;

	@Column (name="NAME")
	private String name;

	private int age;

	@Column (name="AGE")
	public int getAge()
	{
		return this.age
	}

	public String getName()
	{

	}
	// other getter/setters
}
					]]>
				</programlisting>
			</para>

		</note>

		The <literal>@Id</literal> annotation tells the container that <literal>id</literal> is the primary key property.
		The <literal>@GeneratedValue</literal> tells that it should be automatically generated by the container.
		The table name is specified using the <literal>@Table</literal> annotation

		<programlisting>
		<![CDATA[
@Table(name = "PURCHASE_ORDER")
		]]>
		</programlisting>

		If the table name isn't specified it defaults to the simple name of the class. For instance, the LineItem entity would be
		mapped to the LINEITEM table.
	</para>

	<sect5>
		One to Many Relationship :
	</sect5>
	<para>
		The Order bean also defines a one to many relationship.

		<programlisting>
			<![CDATA[
@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy="order")
public Collection<LineItem> getLineItems()
{
   return lineItems;
}
			]]>
		</programlisting>
		Generics must be used so that the container can determine what the entity Order is related to.
		<para>
			<literal>CascadeType.ALL</literal> specifies that when an Order is created, any LineItems held in the <literal>lineItems</literal>
			collection will be created as well (<literal>CascadeType.PERSIST</literal>). If the Order is deleted from persistence storage,
			all related LineItems will be deleted (<literal>CascadeType.REMOVE</literal>). If an Order instance is reattached to persistence
			storage, any changes to the LineItems collection will be merged with persistence storage (<literal>CascadeType.MERGE</literal>).
		</para>

		<para>
			<literal>FetchType.EAGER</literal> specifies that when the Order is loaded whether or not to pre-fetch the relationship as well.
			If you want the LineItems to be loaded on demand, then specify <literal>FetchType.LAZY</literal>.
		</para>

		<para>
			The <literal>mappedBy</literal> attribute specifies that this is a bi-directional relationship that is managed by the order property
			on the LineItem entity.
		</para>

	</para>

	<sect5>
		Many to One Relationship :
	</sect5>
	<para>
		<programlisting>
			<![CDATA[
@ManyToOne
@JoinColumn(name = "order_id")
public Order getOrder()
{
   return order;
}
		]]>
		</programlisting>

		The <literal>@JoinColumn</literal> specifies the foreign key column within the LineItem table.

	</para>

	<sect5>
		EntityManager :
	</sect5>
	<para>
		The <literal>org.jboss.tutorial.entity.bean.ShoppingCartBean</literal> allocates and stores all instances
		of Orders and LineItems. If you look at the example you can see that ShoppingCart interacts with Order as a plain Java object.
		It allocates it with <literal>new</literal>. It can pass the Order back to the client. The <literal>checkout()</literal>
		method actually stores it with persistence storage by using the required EntityManager service.

		The EntityManager service is injected using field injection and the <literal>@PersistenceContext</literal> annotation.
		<programlisting>
			<![CDATA[
@PersistenceContext
private EntityManager manager;

			]]>
		</programlisting>

		The EntityManager is central to EJB 3.0 as there are no homes. The EntityManager is used to do querying, creating,
		find by primary key, and removal of entities in EJB3.
	</para>

	<sect5>
Building and Running
	</sect5>

		<note>
			<para>
	To build and run the example, make sure you have installed JBoss 5.x.
	See the <xref linkend="JBossAS5">installation section</xref> for details.
			</para>
		</note>
		<para>
			From the command prompt, move to the "entity" folder under the <xref linkend="EJB3_TUTORIAL_HOME">EJB3_TUTORIAL_HOME</xref>
		</para>
	<sect5>
Ant Users:
	</sect5>
		<para>
		Make sure your JBossAS-5.x is running
		</para>
	<programlisting>
	<![CDATA[
$ ant
$ ant run

run:
     [java] Buying 2 memory sticks
     [java] Buying a laptop
     [java] Print cart:
     [java] Total: $3000.0
     [java] 2     Memory stick     1000.0
     [java] 1     Laptop     2000.0
     [java] Checkout

     ]]>
	</programlisting>

	<sect5>
Maven Users: Make sure the AS is not running.
	</sect5>

	<programlisting>
$ mvn clean install -PRunSingleTutorial
	</programlisting>

	<sect5>
View the tables and rows:
	</sect5>
	<para>
		You can view the tables created by JBoss by going to the
		<ulink url="http://localhost:8080/jmx-console/HtmlAdaptor?action=inspectMBean&amp;name=jboss%3Aservice%3DHypersonic%2Cdatabase%3DlocalDB">Hypersonic Service</ulink>,
		scrolling down to the <literal>startDatabaseManager</literal> button and clicking it.
		A Hypersonic SQL window will be minimized, but you can open it up to look at the tables and do queries.

	</para>

</chapter>